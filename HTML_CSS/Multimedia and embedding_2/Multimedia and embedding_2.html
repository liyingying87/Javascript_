<!DOCTYPE html>
<html lang="en">
<!--<head>-->
<head>
    <meta charset="UTF-8">
    <!--<title> 元素是一项元数据，用于表示整个 HTML 文档的标题（而不是文档内容）-->
    <title>跟着文档学习HTML和CSS（二）</title>
    <link rel="stylesheet" href="./CSS/M2.css">
    <script src="./js/script.js"></script>
</head>
<body>
<!--HTML中的图片-->
<!-- 备选文本 alt属性 ，它的值应该是对图片的文字描述，用于在图片无法显示或不能被看到的情况。-->
<!--title 这会给我们一个鼠标悬停提示，看起来就像链接标题-->
<img src="img/img.png" alt="The head and torso of a dinosaur skeleton;
          it has a large head with long sharp teeth"
     width="550"
     height="90"
     title="A T-Rex on display in the Manchester University Museum"
>
<div class="figure">
    <img src="img/img.png"
         alt="一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿。"
         width="400"
         height="341">
    <p>曼彻斯特大学博物馆展出的一只霸王龙的化石</p>
    <!--从语义的角度上来讲，<img> 和 <p> 并没有什么联系，这会给使用屏幕阅读的人造成问题，
    比如当你有 50 张图片和其搭配的 50 段说明文字，那么一段说明文字是和哪张图片有关联的呢？
    使用 HTML5 的 <figure> 和 <figcaption> 元素，它正是为此而被创造出来的：
    为图片提供一个语义容器，在标题和图片之间建立清晰的关联。
    -->
</div>
<figure>
    <img src="https://raw.githubusercontent.com/mdn/learning-area/master/html/multimedia-and-embedding/images-in-html/dinosaur_small.jpg"
         alt="一只恐龙头部和躯干的骨架，它有一个巨大的头，长着锋利的牙齿"
         width="400"
         height="341"
    >
    <!--这个 <figcaption> 元素 告诉浏览器和其他辅助的技术工具这段说明文字描述了 <figure> 元素的内容.-->
    <figcaption>曼彻斯特大学博物馆展出的一只霸王龙的化石</figcaption>
</figure>
<!--CSS 背景图片-->
<!--见M2.css
使用css方法相对于 HTML 中插入图片的做法，
可以更好地控制图片和设置图片的位置，那么为什么我们还要使用 HTML 图片呢？
如上所述，CSS 背景图片只是为了装饰 — 如果你只是想要在你的页面上添加一些漂亮的东西，
来提升视觉效果，那 CSS 的做法是可以的。
但是这样插入的图片完全没有语义上的意义，
它们不能有任何备选文本，也不能被屏幕阅读器识别。
这就是 HTML 图片有用的地方了。
总而言之，如果图像对您的内容里有意义，则应使用HTML图像。 如果图像纯粹是装饰，则应使用CSS背景图片。
-->
<!--视频和音频内容-->
<!--<video> 元素 <video> 允许你轻松地嵌入一段视频。-->
<!--src
同 <img> 标签使用方式相同，src 属性指向你想要嵌入网页当中的视频资源，他们的使用方式完全相同。
controls
用户必须能够控制视频和音频的回放功能。你
可以使用 controls 来包含浏览器提供的控件界面，
同时你也可以使用合适的 JavaScript API 创建自己的界面。
界面中至少要包含开始、停止以及调整音量的功能。
<video> 标签内的内容
这个叫做后备内容 — 当浏览器不支持 <video> 标签的时候，就会显示这段内容，
这使得我们能够对旧的浏览器提供回退内容。
你可以添加任何后备内容，在这个例子中我们提供了一个指向这个视频文件的链接，
从而使用户至少可以访问到这个文件，而不会局限于浏览器的支持。
-->
<video src="rabbit320.webm" controls>
    <p>你的浏览器不支持 HTML5 视频。可点击<a href="rabbit320.mp4">此链接</a>观看</p>
</video>
<video controls>
    <source src="rabbit320.mp4" type="video/mp4">
    <!--现在我们将 src 属性从 <video> 标签中移除，
    转而将它放在几个单独的标签 <source> 当中。
    在这个例子当中，浏览器将会检查 <source> 标签，并且播放第一个与其自身 codec 相匹配的媒体。
    你的视频应当包括 WebM 和 MP4 两种格式，这两种在目前已经足够支持大多数平台和浏览器。-->
    <source src="rabbit320.webm" type="video/webm">
    <!--每个 <source> 标签页含有一个 type 属性，这个属性是可选的，但是建议你添加上这个属性 —
    它包含了视频文件的 MIME types ，同时浏览器也会通过检查这个属性来迅速的跳过那些不支持的格式。
    如果你没有添加 type 属性，浏览器会尝试加载每一个文件，直到找到一个能正确播放的格式，这样会消耗掉大量的时间和资源。-->
    <p>你的浏览器不支持 HTML5 视频。可点击<a href="rabbit320.mp4">此链接</a>观看</p>
</video>
<!--autoplay
这个属性会使音频和视频内容立即播放，即使页面的其他部分还没有加载完全。
建议不要应用这个属性在你的网站上，因为用户们会比较反感自动播放的媒体文件。
loop
这个属性可以让音频或者视频文件循环播放。同样不建议使用，除非有必要。
muted
这个属性会导致媒体播放时，默认关闭声音。
poster
这个属性指向了一个图像的URL，这个图像会在视频播放前显示。通常用于粗略的预览或者广告。
preload
这个属性被用来缓冲较大的文件，有3个值可选：
"none" ：不缓冲
"auto" ：页面加载后缓存媒体文件
"metadata" ：仅缓冲文件的元数据
-->
<video controls width="400" height="400"
       loop muted
       poster="./img/poster.png">
    <source src="rabbit320.mp4" type="video/mp4">
    <source src="rabbit320.webm" type="video/webm">
    <p>你的浏览器不支持 HTML5 视频。可点击<a href="rabbit320.mp4">此链接</a>观看</p>
</video>
<!--<audio> 标签与 <video> 标签的使用方式几乎完全相同，有一些细微的差别比如下面的边框不同-->
<audio id="my-media-element" controls>
    <source src="viper.mp3" type="audio/mp3">
    <source src="viper.ogg" type="audio/ogg">
    <p>你的浏览器不支持 HTML5 音频，可点击<a href="viper.mp3">此链接</a>收听。</p>
</audio>
<!--<audio> 标签不支持 width/height 属性 — 由于其并没有视觉部件，也就没有可以设置 width/height 的内容。
同时也不支持 poster 属性 — 同样，没有视觉部件。-->
<!--重新播放媒体
任何时候，你都可以在 Javascript 中调用 load() 方法来重置媒体。如果有多个由 <source> 标签指定的媒体来源，
浏览器会从选择媒体来源开始重新加载媒体。
const mediaElem = document.getElementById("my-media-element");
mediaElem.load();
音轨增删事件
你可以监控媒体元素中的音频轨道，当音轨被添加或删除时，你可以通过监听相关事件来侦测到。具体来说，
通过监听 AudioTrackList (en-US) 对象的 addtrack 事件（即 HTMLMediaElement.audioTracks 对象），
你可以及时对音轨的增加做出响应。
-->
<!--显示音轨文本
-->
<video controls>
    <source src="example.mp4" type="video/mp4">
    <source src="example.webm" type="video/webm">
    <!--WebVTT 是一个格式，用来编写文本文件，这个文本文件包含了众多的字符串，
    这些字符串会带有一些元数据，它们可以用来描述这个字符串将会在视频中显示的时间，
    甚至可以用来描述这些字符串的样式以及定位信息。
    这些字符串叫做 cues ，你可以根据不同的需求来显示不同的样式，-->
    <track kind="subtitles" src="./subtitles_en.vtt" srclang="en">
    <!--让其与 HTML 媒体一起显示，你需要做如下工作：
    1.以 .vtt 后缀名保存文件。
    2.用 <track> 标签链接 .vtt 文件， <track> 标签需放在 <audio> 或 <video> 标签当中，
    同时需要放在所有 <source> 标签之后。
    使用 kind 属性来指明是哪一种类型，如 subtitles 、 captions 、 descriptions。
    然后，使用 srclang 来告诉浏览器你是用什么语言来编写的 subtitles。-->
    <!--这里显示音轨文本，没显示成功，等多会用，多会再弄吧-->
</video>
<!--从对象到iframe - 其他嵌入技术-->
<!-- <iframe>, <embed> 和<object> 元素。<iframe>用于嵌入其他网页，另外两个元素则允许您嵌入PDF，SVG，
甚至Flash — 一种正在被淘汰的技术.-->
<!--<iframe>元素出现了（连同其他嵌入内容的方式，如<canvas>，<video>等），
它提供了一种将整个web页嵌入到另一个网页的方法，看起来就像那个web页是另一个网页的一个<img>或其他元素一样。
<iframe>现在经常被使用。-->
<iframe src="https://developer.mozilla.org/en-US/docs/Glossary"
        width="100%" height="500" frameborder="0"
        allowfullscreen sandbox>
    <p><a href="https://developer.mozilla.org/en-US/docs/Glossary">
        Fallback link for browsers that don't support iframes
    </a></p>
</iframe>
<iframe width="560" height="315"
        src="https://www.youtube.com/embed/lLDb3diAHPQ"
        title="YouTube video player"
        frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen>
</iframe>
<!--iframe 的基本要素
allowfullscreen
如果设置，<iframe>则可以通过全屏API设置为全屏模式（稍微超出本文的范围）。
frameborder
如果设置为1，则会告诉浏览器在此框架和其他框架之间绘制边框，这是默认行为。0删除边框。不推荐这样设置，因为在CSS中可以更好地实现相同的效果。border: none;
备选内容
与<video>等其他类似元素相同，您可以在<iframe></iframe>标签之间包含备选内容，如果浏览器不支持<iframe>，将会显示备选内容，这种情况下，我们已经添加了一个到该页面的链接。现在您几乎不可能遇到任何不支持<iframe>的浏览器。
sandbox
该属性需要在已经支持其他<iframe>功能（例如IE 10及更高版本）但稍微更现代的浏览器上才能工作，该属性可以提高安全性设置; 我们将在下一节中更加详细地谈到。
-->
<!--安全隐患
只有在必要时候嵌入
使用HTTPS
始终使用sandbox属性
    想尽可能减少攻击者在你的网站上做坏事的机会，
    那么你应该给嵌入的内容仅能完成自己工作的权限。
    当然，这也适用于你自己的内容。一个允许包含在其里的代码以适当的方式执行或者用于测试，
    但不能对其他代码库（意外或恶意）造成任何损害的容器称为沙盒。
配置CSP指令
    CSP代表内容安全策略，它提供一组HTTP标头
    （由web服务器发送时与元数据一起发送的元数据），旨在提高HTML文档的安全性。
    在<iframe>s安全性方面，您可以将服务器配置为发送适当的X-Frame-Options  标题。
    这样做可以防止其他网站在其网页中嵌入您的内容（这将导致点击和一系列其他攻击），正如我们之前看到的那样，
    MDN开发人员已经做了这些工作。
-->
<!--<embed>和<object>元素 是用来嵌入多种类型的外部内容的通用嵌入工具，其中包括像Java小程序和Flash，PDF（可在浏览器中显示为一个PDF插件）这样的插件技术，甚至像视频，SVG和图像的内容！-->
<embed src="whoosh.swf" quality="medium"
       bgcolor="#ffffff" width="550" height="400"
       name="whoosh" align="middle" allowScriptAccess="sameDomain"
       allowFullScreen="false" type="application/x-shockwave-flash"
       pluginspage="http://www.macromedia.com/go/getflashplayer">
<object data="mypdf.pdf" type="application/pdf"
        width="800" height="1200" typemustmatch>
    <p>You don't have a PDF plugin, but you can <a href="myfile.pdf">download the PDF file.</a></p>
</object>
<!--在网页中添加矢量图形-->
<!--在网上，你会和两种类型的图片打交道 — 位图和矢量图:
位图使用像素网格来定义 — 一个位图文件精确得包含了每个像素的位置和它的色彩信息。流行的位图格式包括 Bitmap (.bmp), PNG (.png), JPEG (.jpg), and GIF (.gif.)
矢量图使用算法来定义 — 一个矢量图文件包含了图形和路径的定义，电脑可以根据这些定义计算出当它们在屏幕上渲染时应该呈现的样子。 SVG 格式可以让我们创造用于 Web 的精彩的矢量图形。
-->
<!--SVG是什么？
SVG 是用于描述矢量图像的XML语言。 它基本上是像HTML一样的标记，只是你有许多不同的元素来定义要显示在图像中的形状，以及要应用于这些形状的效果。
 SVG用于标记图形，而不是内容。 非常简单，你有一些元素来创建简单图形，如<circle> 和<rect>。
 更高级的SVG功能包括 <feColorMatrix>（使用变换矩阵转换颜色）<animate> （矢量图形的动画部分）和 <mask>（在图像顶部应用模板）
-->
<svg version="1.1"
     baseProfile="full"
     width="300" height="200"
     xmlns="http://www.w3.org/2000/svg">
    <rect width="100%" height="100%" fill="black" />
    <circle cx="150" cy="100" r="90" fill="blue" />
</svg>
<!-- 为了创建SVG图像，大多数人使用矢量图形编辑器，如 Inkscape 或 Illustrator。-->
<!--优点：
矢量图像中的文本仍然可访问（这也有利于 SEO)）。
SVG 可以很好地适应样式/脚本，因为图像的每个组件都是可以通过CSS或通过JavaScript编写的样式的元素。-->
<!--SVG 确实有一些缺点：
SVG非常容易变得复杂，这意味着文件大小会增加; 复杂的SVG也会在浏览器中占用很长的处理时间。
SVG可能比栅格图像更难创建，具体取决于您尝试创建哪种图像。
旧版浏览器不支持SVG，因此如果您需要在网站上支持旧版本的 IE，则可能不适合（SVG从IE9开始得到支持）。-->
<svg width="300" height="200">
    <rect width="100%" height="100%" fill="green" />
</svg>
<iframe src="triangle.svg" width="500" height="500" sandbox>
    <img src="triangle.png" alt="Triangle with three unequal sides" />
</iframe>
<!--响应式图片  怎样创建自适应的图片?-->
<img src="./img/img.png" alt="Elva dressed as a fairy">
</body>
</html>
