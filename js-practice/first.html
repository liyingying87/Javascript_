<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //         console.log("-----1----");
        //         let result1 = Number.MAX_VALUE + Number.MAX_VALUE;
        //         console.log(isFinite(result1));

        //         console.log("-----2.1模板字面量标签函数----");
        //         //模板字面量
        //         let a = 6, b = 9;
        //         function zipTag(Strings, ...expressions) {
        //             console.log(Strings);
        //             expressions.map((e, i) => console.log(e + " " + i));

        //             return Strings[0] + expressions.map((e, i) => `${e}${Strings[i + 1]}`).join('');
        //         }
        //         let un = `${a}-${b}=${a * b}+${a + b}`;
        //         let ok = zipTag`${a}-${b}=${a * b}+${a + b}`;
        //         console.log(un);
        //         console.log("ok.0   " + un[0]);
        //         console.log(ok);
        //         //
        //         console.log("-----2.2模板字面量标签函数----");
        //         let name = 'xuBoBo';
        //         let age = 24;
        //         let hobby = 'study';
        //         function person(String, name, hobby) {
        //             console.log(String);
        //             console.log(name);
        //             console.log(hobby)
        //             return 'niHao'
        //         }

        //         let result = person`${name}他的年龄是${age},他的爱好是${hobby}+${a}`
        //         console.log(result)
        //         console.log("-----2.3 原始字符串----");
        //         // Unicode示例
        //         // \u00A9是版权符号
        //         console.log(`\u00A9`); // ©
        //         console.log(String.raw`\u00A9`); // \u00A9
        //         // 换行符示例
        //         console.log(`first line\nsecond line`);
        //         // first line
        //         // second line
        //         console.log(String.raw`first line\nsecondline`); // "first line\nsecond line"
        //         // 对实际的换行符来说是不行的
        //         // 它们不会被转换成转义序列的形式
        //         console.log(`first line
        // second line`);
        //         // first line
        //         // second line
        //         console.log(String.raw`first line
        // second line`);
        //         // first line
        //         // second line


        //         function printRaw(strings) {
        //             console.log('Actual characters:');
        //             for (const string of strings) {
        //                 console.log(string);
        //             }
        //             console.log('Escaped characters;');
        //             for (const rawString of strings.raw) {
        //                 console.log(rawString);
        //             }
        //         }
        //         printRaw`\u00A9${'and'}\n`;
        //         // Actual characters:
        //         // ©
        //         //（换行符）
        //         // Escaped characters:
        //         // \u00A9
        //         // \n
        //         console.log("-----Symbol----");
        //         let s1 = Symbol('foo'),
        //             s2 = Symbol('bar'),
        //             s3 = Symbol('baz'),
        //             s4 = Symbol('qux');
        //         let o = {
        //             [s1]: 'foo val'
        //         };
        //         // 这样也可以：o[s1] = 'foo val'; 
        //         console.log(o);
        //         // {Symbol(foo): foo val} 
        //         Object.defineProperty(o, s2, { value: 'bar val' });
        //         console.log(o);
        //         // {Symbol(foo): foo val, Symbol(bar): bar val} 
        //         Object.defineProperties(o, {
        //             [s3]: { value: 'baz val' },
        //             [s4]: { value: 'qux val' }
        //         });
        //         console.log(o);
        //         // {Symbol(foo): foo val, Symbol(bar): bar val,
        //         // Symbol(baz): baz val, Symbol(qux): qux val}
        //         console.log("-----Symbol----");
        //         var asyncIterable = {
        //             [Symbol.asyncIterator]() {
        //                 return {
        //                     i: 0,
        //                     next() {
        //                         if (this.i < 3) {
        //                             return Promise.resolve({ value: this.i++, done: false });
        //                         }

        //                         return Promise.resolve({ done: true });
        //                     }
        //                 };
        //             }
        //         };

        //         (async function () {
        //             for await (num of asyncIterable) {
        //                 console.log(num);
        //             }
        //         })();

        //         // 0
        //         // 1
        //         // 2
        //         console.log("-----Symbol----");
        //         class Array1 {
        //             static [Symbol.hasInstance](instance) {
        //                 return Array.isArray(instance);
        //             }
        //         }

        //         console.log([] instanceof Array1);
        //         // expected output: true
        //         console.log("-----Symbol----");
        //         class MyClass {
        //             [Symbol.hasInstance](foo) {
        //                 return foo instanceof Array;
        //             }

        //             static [Symbol.hasInstance](obj) {
        //                 return Number(obj) % 2 === 0;
        //             }
        //         }
        //         var x = new MyClass()
        //         console.log([1, 2, 3] instanceof new MyClass()); // true //我是调用的动态方法
        //         console.log(x[Symbol.hasInstance]([0, 0, 0,]));//true //我是调用的动态方法
        //         console.log(2 instanceof MyClass); //true 我是调用静态方法
        //         console.log(MyClass[Symbol.hasInstance](2));//true 我是调用了静态方法
        //         console.log(x instanceof MyClass); //false 因为修改了静态方法。x本身就是MyClass的实例，如果注释了静态方法就会返回true。


        //         console.log(RegExp.prototype[Symbol.match]);
        //         console.log('foobar'.match(/bar/));

        //         class Split1 {
        //             constructor(value) {
        //                 this.value = value;
        //             }
        //             [Symbol.split](string) {
        //                 const index = string.indexOf(this.value);
        //                 return `${this.value}${string.substr(0, index)}/${string.substr(index + this.value.length)}`;
        //             }
        //         }

        //         console.log('foobar'.split(new Split1('foo')));
        // expected output: "foo/bar"
        console.log("-----Symbol----");
        const object1 = {
            [Symbol.toPrimitive](hint) {
                console.log(hint);
                if (hint === 'number') {
                    console.log(hint);
                    return 42;
                }
                return null;
            }
        };

        console.log(+object1);
        // 一个没有提供 Symbol.toPrimitive 属性的对象，参与运算时的输出结果
        var obj1 = {};
        console.log(+obj1);     // NaN
        console.log(`${obj1}`); // "[object Object]"
        console.log(obj1 + ""); // "[object Object]"

        // 接下面声明一个对象，手动赋予了 Symbol.toPrimitive 属性，再来查看输出结果
        var obj2 = {
            [Symbol.toPrimitive](hint) {
                if (hint == "number") {
                    return 10;
                }
                if (hint == "string") {
                    return "hello";
                }
                return true;
            }
        };
        console.log(+obj2);     // 10      -- hint 参数值是 "number"
        console.log(`${obj2}`); // "hello" -- hint 参数值是 "string"
        console.log(obj2 + ""); // "true"  -- hint 参数值是 "default"
// expected output: 42
    </script>
</body>

</html>